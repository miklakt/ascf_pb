import importlib
import pathlib
import functools
import inspect
from typing import Callable, List
from collections import OrderedDict
import ascf_pb.topology
from ascf_pb import solver

def combine_signatures(
        callables: List[Callable],
        exclude=[],
        return_annotation=inspect.Signature.empty
):

    signatures = [inspect.signature(c) for c in callables]
    params = {key: param for sig in signatures for key,
              param in sig.parameters.items() if key not in exclude}
    signature = inspect.Signature(
        params.values(), return_annotation=return_annotation)

    return signature


def generate_docstring(signature: inspect.Signature, return_name):
    header = f'Calculates {__return_description[return_name]} for given arguments'

    args_desc = []
    for k, v in signature.parameters.items():
        if v.default is inspect.Parameter.empty:
            args_desc.append(
                f'{k} ({v.annotation.__name__}) : {__arg_description[k]}')
        else:
            args_desc.append(
                f'{k} ({v.annotation.__name__}, optional) : {__arg_description[k]}. Defaults to {v.default}')
    args_section = '\nArgs:\n' +\
        '\n'.join(args_desc)

    return_section = '\nReturns:' + \
        f'\n({signature.return_annotation.__name__}): ' + \
        f'{__return_description[return_name]}'

    return header+args_section+return_section


def generate_annotation(signature: inspect.Signature):
    annotations = {k: v.annotation for k, v in signature.parameters.items()}
    annotations["return"] = signature.return_annotation
    return annotations


def ignore_extra_kwargs(func : Callable) -> Callable:
    """Decorator that allows to call functions with redundant kwargs, 
    so that the function only uses required ones.
    """
    parameters = inspect.signature(func).parameters

    def wrapped(**kwargs):
        new_kwargs = {k: kwargs[k] for k in kwargs if k in parameters}
        return func(**new_kwargs)
    wrapped.__annotations__ = func.__annotations__
    wrapped.__doc__ = func.__doc__
    wrapped.__name__ = func.__name__
    wrapped.__module__ = func.__module__
    return wrapped


__arg_description = OrderedDict(
    N='polymer chain length',
    sigma='polymer brush grafting density',
    chi='Flory-Huggins parameter polymer-solvent',
    pore_Radius='grafted pore radius',
    R='distance from to grafting surface to the restriction',
    z='distance from grafting surface',
    ph="particle height",
    pw="particle width",
    pc="particle center",
    chi_PC='Flory-Huggins parameter polymer-particle',
    expansion_coefs="polynomial coefficients of gamma - phi dependency",
    eta="topological parameter",
    g="dendron generations",
    q="dendron functionality"
)

__return_description = dict(
    D="polymer brush's thickness",
    osmotic_free_energy="osmotic part of the insertion free energy change",
    surface_free_energy="surface interaction contribution of the insertion free energy change",
    total_free_energy="total free energy of an inserted particle",
    phi='local polymer volume fraction',
    phi_D='local polymer volume fraction at the brush\'s end',
    Pi='local osmotic pressure',
    critical_pore_radius='minimal radius of an open pore'
)

# %%


class BrushSolver:
    def __init__(self, geometry: str = 'plain') -> None:
        self.geometry = geometry
        self.__geometry_module = importlib.import_module(
            f"brush_geometry.{geometry}")
        self.phi_D_callback = self.__geometry_module.phi_D_universal
        self.D_callback = self.__geometry_module.D_universal
        self.kappa_callback = ascf_pb.topology.kappa

    def __build_phi(self) -> Callable:
        signature = combine_signatures([self.phi_D_callback, self.D_callback, self.kappa_callback], exclude=["kappa"])
        def phi(*args, **kwargs):
            kappa = ignore_extra_kwargs(self.kappa_callback)(*args, **kwargs)
            phi_D = ignore_extra_kwargs(self.phi_D_callback)(*args, **kwargs, kappa=kappa)
            D = ignore_extra_kwargs(self.D_callback)(*args, **kwargs, kappa=kappa)
            phi = ignore_extra_kwargs(solver.Phi)(*args, **kwargs, d=D, phi_D = D)

b = BrushSolver()
# %%
sig = combine_signatures([b.phi_D_callback, b.D_callback, ascf_pb.topology.kappa], exclude=[
                         "kappa"], return_annotation=float)
print(generate_docstring(sig, "phi"))
ann =generate_annotation(sig)
# %%
b.phi_D_callback.__annotations__ = ann
b.phi_D_callback.__signature__ = sig
# %%
inspect.signature(b.phi_D_callback)
# %%
